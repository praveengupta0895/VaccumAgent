# -*- coding: utf-8 -*-
"""VaccumRobot.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1Di7241oxooGw6Z1IZoH2ked103VFnE_7
"""

"""Author: Cody Dronet"""
import copy
import math
import time


class Room:
    # Cell will be a matrix of D's and C's where D's are dirty cells and C's are clean cells
    # Position defines where the Robot is currently located [x,y] format
    def __init__(self, cell, position, size):
        self.cell = cell
        self.position = position


class Node:

    # Data is a refrence to a room object
    # Level is the node's current level in the tree
    # Fval is the nodes calulated f value
    def __init__(self, data, level, fval, parent):
        self.data = data
        self.level = level
        self.fval = fval
        self.parent = parent

    def showInfo(self):
        print("NODE LEVEL:", self.level)
        print("ROBOT POSITION:", self.data.position)
        print("NODE FVAL:", self.fval)
        print("NODE BOARD:")
        for i in self.data.cell:
            for j in i:
                print(j, end=" ")
            print("")

    # Generates leaf nodes
    def generate_children(self):

        children = []

        # Generate children for all 5 actions
        # 1 - right, 2 - left, 3 - down , 4 - up, 0 - suck
        for i in range(0, 5):
            childroom = self.change(copy.deepcopy(self.data), i)
            if (childroom is not None):
                childnode = Node(childroom, copy.copy(self.level) + 1, 0, self)
                # childnode.showInfo()
                children.append(childnode)
        return children

    # Generate new node based on action
    # If invalid move, return None
    def change(self, room, action):
        temproom = room

        # Suck
        if action == 0:
            temproom.cell[room.position[1]][room.position[0]] = 'C'
            return temproom
        # Right

        if action == 1:
            temproom.position = (room.position[0] + 1, room.position[1])
            if (temproom.position[0] > 2):
                return None
            return temproom
        # Left
        if action == 2:
            temproom.position = (room.position[0] - 1, room.position[1])
            if (temproom.position[0] < 0):
                return None
            return temproom
        # Up
        if action == 3:
            temproom.position = (room.position[0], room.position[1] - 1)
            if (temproom.position[1] > 2):
                return None
            return temproom
        # Down
        if action == 4:
            temproom.position = (room.position[0], room.position[1] + 1)
            if (temproom.position[1] < 0):
                return None
            return temproom

        # Error
        else:
            return None


class Problem:
    def __init__(self):
        self.open = []
        self.closed = []

    def solution(self, cur):
        mystack = []
        while (cur != None):
            mystack.append(cur)
            cur = cur.parent
        while (mystack):
            mystack.pop().showInfo()

    def f(self, start, goal):
        return self.h(start.data.cell, goal, copy.copy(start.data.position)) + copy.copy(start.level)

    def h(self, start, goal, pos):
        temp = 0
        # +1 for each dirty square
        for i in range(0, 3):
            for j in range(0, 3):
                if start[i][j] != goal[i][j]:
                    temp += 2
        # +1 for each square away from closest dirty sqaure
        dpos = []
        dist = []

        # Get list of cords for all dirty squares
        for i in range(0, 3):
            for j in range(0, 3):
                if (start[j][i] == 'D'):
                    dpos.append((i, j))
        for x in dpos:
            dist.append(abs(pos[0] - x[0]) + abs(pos[1] - x[1]))
        dist.sort()
        if (dist):
            temp += dist[0]

        return temp

    def process(self):

        print("Started process!")
        startcells = [['D', 'D', 'D'],
                      ['C', 'C', 'D'],
                      ['C', 'C', 'D']]

        goal = [['C', 'C', 'C'],
                ['C', 'C', 'C'],
                ['C', 'C', 'C']]

        testpos = (1, 1)
        testsize = 3
        testroom = Room(startcells, testpos, testsize)

        startnode = Node(testroom, 0, 0, None)
        startnode.fval = self.f(startnode, goal)
        self.open.append(startnode)

        while True:
            print("\n")
            cur = self.open[0]
            print("NEW CURRENT NODE")
            cur.showInfo()
            if (self.h(cur.data.cell, goal, cur.data.position) == 0):
                print("\n~~Found Solution~~")
                self.solution(cur)
                print("Got Goal!")
                break
            for i in cur.generate_children():
                i.fval = self.f(i, goal)
                self.open.append(i)
            self.closed.append(cur)
            del self.open[0]
            """Sort the list based on f value"""
            self.open.sort(key=lambda x: x.fval, reverse=False)


newprob = Problem()
newprob.process()